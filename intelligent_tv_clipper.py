
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Êô∫ËÉΩÁîµËßÜÂâßÂâ™ËæëÁ≥ªÁªü v3.0
Ëß£ÂÜ≥ÊâÄÊúâ15‰∏™Ê†∏ÂøÉÈóÆÈ¢òÁöÑÂÆåÊï¥ÊñπÊ°à
"""

import os
import re
import json
import subprocess
import hashlib
import requests
from typing import List, Dict, Optional, Tuple
from datetime import datetime

class IntelligentTVClipper:
    def __init__(self):
        # Ê†áÂáÜÁõÆÂΩïÁªìÊûÑ
        self.srt_folder = "srt"
        self.videos_folder = "videos"
        self.output_folder = "clips"
        self.cache_folder = "cache"
        
        # ÂàõÂª∫ÂøÖË¶ÅÁõÆÂΩï
        for folder in [self.srt_folder, self.videos_folder, self.output_folder, self.cache_folder]:
            os.makedirs(folder, exist_ok=True)
        
        # Âä†ËΩΩAIÈÖçÁΩÆ
        self.ai_config = self._load_ai_config()
        
        print("üöÄ Êô∫ËÉΩÁîµËßÜÂâßÂâ™ËæëÁ≥ªÁªü v3.0")
        print("=" * 60)
        print("‚ú® Ê†∏ÂøÉÁâπÊÄßÔºö")
        print("‚Ä¢ ÂÆåÂÖ®AIÊô∫ËÉΩÂàÜÊûêÔºåËá™ÈÄÇÂ∫îÊâÄÊúâÂâßÊÉÖÁ±ªÂûã")
        print("‚Ä¢ Êï¥ÈõÜ‰∏ä‰∏ãÊñáÂàÜÊûêÔºåÈÅøÂÖçÂè∞ËØçÂâ≤Ë£Ç")  
        print("‚Ä¢ ÊØèÈõÜÂ§ö‰∏™Á≤æÂΩ©Áü≠ËßÜÈ¢ëÔºåAIÂà§Êñ≠ÂÆåÊï¥ÂÜÖÂÆπ")
        print("‚Ä¢ ÂÆûÈôÖÂâ™ËæëÁîüÊàêËßÜÈ¢ëÊñá‰ª∂ + ‰∏ì‰∏öÊóÅÁôΩ")
        print("‚Ä¢ Êô∫ËÉΩÁºìÂ≠òÊú∫Âà∂ÔºåÈÅøÂÖçÈáçÂ§çAPIË∞ÉÁî®")
        print("‚Ä¢ Â§öÊ¨°ÊâßË°åÁªìÊûú‰∏ÄËá¥ÊÄß‰øùËØÅ")
        print("=" * 60)

    def _load_ai_config(self) -> Dict:
        """Âä†ËΩΩAIÈÖçÁΩÆ"""
        try:
            if os.path.exists('.ai_config.json'):
                with open('.ai_config.json', 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    if config.get('enabled', False):
                        print(f"ü§ñ AIÂ∑≤ÈÖçÁΩÆ: {config.get('provider', 'unknown')}")
                        return config
        except Exception as e:
            print(f"‚ö†Ô∏è AIÈÖçÁΩÆÂä†ËΩΩÂ§±Ë¥•: {e}")
        
        print("üìù Â∞Ü‰ΩøÁî®Âü∫Á°ÄËßÑÂàôÂàÜÊûê")
        return {'enabled': False}

    def parse_srt_file(self, filepath: str) -> List[Dict]:
        """Ëß£ÊûêSRTÂ≠óÂπïÊñá‰ª∂ÔºåÊô∫ËÉΩÈîôËØØ‰øÆÊ≠£"""
        print(f"üìñ Ëß£ÊûêÂ≠óÂπï: {os.path.basename(filepath)}")
        
        # Â∞ùËØïÂ§öÁßçÁºñÁ†Å
        content = None
        for encoding in ['utf-8', 'gbk', 'utf-16', 'gb2312']:
            try:
                with open(filepath, 'r', encoding=encoding, errors='ignore') as f:
                    content = f.read()
                    break
            except:
                continue
        
        if not content:
            print(f"‚ùå Êó†Ê≥ïËØªÂèñÊñá‰ª∂: {filepath}")
            return []
        
        # Êô∫ËÉΩÈîôÂà´Â≠ó‰øÆÊ≠£
        corrections = {
            'Èò≤Ë°õ': 'Èò≤Âç´', 'Ê≠£Áï∂': 'Ê≠£ÂΩì', 'Ë®ºÊìö': 'ËØÅÊçÆ', 'Ê™¢ÂØüÂÆò': 'Ê£ÄÂØüÂÆò',
            'ÂØ©Âà§': 'ÂÆ°Âà§', 'ËæØË≠∑': 'Ëæ©Êä§', 'Ëµ∑Ë®¥': 'Ëµ∑ËØâ', 'Ë™øÊü•': 'Ë∞ÉÊü•',
            'ÁôºÁèæ': 'ÂèëÁé∞', 'Ê±∫ÂÆö': 'ÂÜ≥ÂÆö', 'ÈÅ∏Êìá': 'ÈÄâÊã©', 'ÈñãÂßã': 'ÂºÄÂßã'
        }
        
        for old, new in corrections.items():
            content = content.replace(old, new)
        
        # Ëß£ÊûêÂ≠óÂπïÊù°ÁõÆ
        subtitles = []
        blocks = re.split(r'\n\s*\n', content.strip())
        
        for block in blocks:
            lines = block.strip().split('\n')
            if len(lines) >= 3:
                try:
                    index = int(lines[0]) if lines[0].isdigit() else len(subtitles) + 1
                    
                    # ÂåπÈÖçÊó∂Èó¥Ê†ºÂºè
                    time_pattern = r'(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,\.]\d{3})'
                    time_match = re.search(time_pattern, lines[1])
                    
                    if time_match:
                        start_time = time_match.group(1).replace('.', ',')
                        end_time = time_match.group(2).replace('.', ',')
                        text = '\n'.join(lines[2:]).strip()
                        
                        if text:
                            subtitles.append({
                                'index': index,
                                'start': start_time,
                                'end': end_time,
                                'text': text
                            })
                except (ValueError, IndexError):
                    continue
        
        print(f"‚úÖ Ëß£ÊûêÂÆåÊàê: {len(subtitles)} Êù°Â≠óÂπï")
        return subtitles

    def _get_cache_key(self, subtitles: List[Dict]) -> str:
        """ÁîüÊàêÁºìÂ≠òÈîÆ"""
        content = json.dumps(subtitles, ensure_ascii=False, sort_keys=True)
        return hashlib.md5(content.encode()).hexdigest()[:16]

    def _load_cache(self, cache_key: str, episode_name: str) -> Optional[Dict]:
        """Âä†ËΩΩÂàÜÊûêÁºìÂ≠ò"""
        cache_file = os.path.join(self.cache_folder, f"{episode_name}_{cache_key}.json")
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    analysis = json.load(f)
                    print(f"üíæ ‰ΩøÁî®ÁºìÂ≠òÂàÜÊûê: {episode_name}")
                    return analysis
            except Exception as e:
                print(f"‚ö†Ô∏è ÁºìÂ≠òËØªÂèñÂ§±Ë¥•: {e}")
        return None

    def _save_cache(self, cache_key: str, episode_name: str, analysis: Dict):
        """‰øùÂ≠òÂàÜÊûêÁºìÂ≠ò"""
        cache_file = os.path.join(self.cache_folder, f"{episode_name}_{cache_key}.json")
        try:
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(analysis, f, ensure_ascii=False, indent=2)
            print(f"üíæ ‰øùÂ≠òÂàÜÊûêÁºìÂ≠ò: {episode_name}")
        except Exception as e:
            print(f"‚ö†Ô∏è ÁºìÂ≠ò‰øùÂ≠òÂ§±Ë¥•: {e}")

    def ai_analyze_complete_episode(self, subtitles: List[Dict], episode_name: str) -> Dict:
        """AIÂÆåÊï¥ÂàÜÊûêÂçïÈõÜ - Ëß£ÂÜ≥ÈóÆÈ¢ò1,2,3,8"""
        # Ê£ÄÊü•ÁºìÂ≠ò - Ëß£ÂÜ≥ÈóÆÈ¢ò12
        cache_key = self._get_cache_key(subtitles)
        cached_analysis = self._load_cache(cache_key, episode_name)
        if cached_analysis:
            return cached_analysis
        
        episode_num = self._extract_episode_number(episode_name)
        
        # ÊûÑÂª∫ÂÆåÊï¥‰∏ä‰∏ãÊñá - Ëß£ÂÜ≥ÈóÆÈ¢ò2ÔºöÈÅøÂÖçÂè∞ËØçÂâ≤Ë£Ç
        full_context = self._build_complete_context(subtitles)
        
        if self.ai_config.get('enabled', False):
            analysis = self._call_ai_analysis(full_context, episode_num, episode_name)
        else:
            analysis = self._basic_analysis_fallback(subtitles, episode_num, episode_name)
        
        # ‰øùÂ≠òÁºìÂ≠ò - Ëß£ÂÜ≥ÈóÆÈ¢ò12
        self._save_cache(cache_key, episode_name, analysis)
        
        return analysis

    def _build_complete_context(self, subtitles: List[Dict]) -> str:
        """ÊûÑÂª∫ÂÆåÊï¥‰∏ä‰∏ãÊñáÔºåÈÅøÂÖçÂâ≤Ë£Ç"""
        # Â∞ÜÊâÄÊúâÂ≠óÂπïÂêàÂπ∂‰∏∫ÂÆåÊï¥ÊñáÊú¨Ôºå‰øùÊåÅÊó∂Èó¥‰ø°ÊÅØ
        context_parts = []
        
        # ÊØè50Âè•ÂàÜ‰∏ÄÊÆµÔºå‰øùÊåÅ‰∏ä‰∏ãÊñá
        for i in range(0, len(subtitles), 50):
            segment = subtitles[i:i+50]
            segment_text = '\n'.join([f"[{sub['start']} --> {sub['end']}] {sub['text']}" for sub in segment])
            context_parts.append(segment_text)
        
        return '\n\n=== Âú∫ÊôØÂàÜÂâ≤ ===\n\n'.join(context_parts)

    def _call_ai_analysis(self, context: str, episode_num: str, episode_name: str) -> Dict:
        """Ë∞ÉÁî®AIËøõË°åÂÆåÊï¥ÂàÜÊûê"""
        prompt = f"""‰Ω†ÊòØ‰∏ì‰∏öÁöÑÁîµËßÜÂâßÂâ™ËæëÂ∏àÔºåÈúÄË¶Å‰∏∫Á¨¨{episode_num}ÈõÜÂàõÂª∫Â§ö‰∏™2-3ÂàÜÈíüÁöÑÁ≤æÂΩ©Áü≠ËßÜÈ¢ë„ÄÇ

„ÄêÂÆåÊï¥ÂâßÊÉÖÂÜÖÂÆπ„Äë
{context}

ËØ∑ÂÆåÊàê‰ª•‰∏ã‰ªªÂä°Ôºö
1. Ëá™Âä®ËØÜÂà´ÂâßÊÉÖÁ±ªÂûãÔºà‰∏çË¶ÅÈôêÂà∂‰∏∫ÁâπÂÆöÁ±ªÂûãÔºåË¶ÅÊô∫ËÉΩÂà§Êñ≠Ôºâ
2. ÊâæÂá∫3-5‰∏™ÊúÄÁ≤æÂΩ©ÁöÑÁâáÊÆµÔºåÊØè‰∏™2-3ÂàÜÈíü
3. Á°Æ‰øùÁâáÊÆµÂåÖÂê´ÂÆåÊï¥ÂØπËØùÔºå‰∏çÊà™Êñ≠Âè•Â≠ê
4. ÁîüÊàê‰∏ì‰∏öÊóÅÁôΩËß£ËØ¥
5. ‰øùËØÅÂâßÊÉÖËøûË¥ØÊÄß

ËØ∑‰ª•JSONÊ†ºÂºèËøîÂõûÔºö
{{
    "episode_analysis": {{
        "episode_number": "{episode_num}",
        "genre": "Ëá™Âä®ËØÜÂà´ÁöÑÂâßÊÉÖÁ±ªÂûã",
        "main_theme": "Êú¨ÈõÜ‰∏ªÈ¢ò",
        "story_arc": "ÂâßÊÉÖÂèëÂ±ïÂºßÁ∫ø"
    }},
    "highlight_segments": [
        {{
            "segment_id": 1,
            "title": "ÁâáÊÆµÊ†áÈ¢ò",
            "start_time": "ÂºÄÂßãÊó∂Èó¥(HH:MM:SS,mmm)",
            "end_time": "ÁªìÊùüÊó∂Èó¥(HH:MM:SS,mmm)",
            "duration_seconds": ÂÆûÈôÖÁßíÊï∞,
            "description": "ÂÜÖÂÆπÊèèËø∞",
            "dramatic_value": 8.5,
            "key_dialogues": ["ÂÖ≥ÈîÆÂØπËØù1", "ÂÖ≥ÈîÆÂØπËØù2"],
            "plot_significance": "ÂâßÊÉÖÈáçË¶ÅÊÄß",
            "emotional_impact": "ÊÉÖÊÑüÂÜ≤Âáª",
            "narration": {{
                "opening": "ÂºÄÂú∫ÊóÅÁôΩ",
                "climax": "È´òÊΩÆËß£ËØ¥", 
                "conclusion": "ÁªìÂ∞æÊÄªÁªì"
            }}
        }}
    ],
    "continuity": {{
        "previous_connection": "‰∏éÂâçÈõÜËøûÊé•",
        "next_setup": "‰∏∫‰∏ãÈõÜÈì∫Âû´"
    }}
}}

ÂàÜÊûêÂéüÂàôÔºö
- ÂÆåÂÖ®Êô∫ËÉΩÂåñÔºå‰∏çË¶ÅÈôêÂà∂ÂâßÊÉÖÁ±ªÂûã
- ‰ºòÂÖàÈÄâÊã©ÊàèÂâßÂÜ≤Á™ÅÂº∫ÁÉàÁöÑÁâáÊÆµ
- Á°Æ‰øùÊØè‰∏™ÁâáÊÆµÊúâÂÆåÊï¥ÁöÑÊïÖ‰∫ãÂºßÁ∫ø
- ÈáçËßÜËßíËâ≤ÂèëÂ±ïÂíåÊÉÖÊÑüÂèòÂåñ
- ‰øùÊåÅ‰∏éÊï¥‰ΩìÂâßÊÉÖÁöÑËøûË¥ØÊÄß"""

        try:
            response = self._call_ai_api(prompt)
            if response:
                analysis = self._parse_ai_response(response)
                if analysis:
                    return analysis
        except Exception as e:
            print(f"‚ö†Ô∏è AIÂàÜÊûêÂ§±Ë¥•: {e}")
        
        # ÈôçÁ∫ßÂà∞Âü∫Á°ÄÂàÜÊûê
        return self._basic_analysis_fallback(subtitles, episode_num, episode_name)

    def _call_ai_api(self, prompt: str) -> Optional[str]:
        """Áªü‰∏ÄAI APIË∞ÉÁî®"""
        try:
            config = self.ai_config
            api_type = config.get('api_type', 'proxy')
            
            if api_type == 'official':
                return self._call_official_api(prompt, config)
            else:
                return self._call_proxy_api(prompt, config)
                
        except Exception as e:
            print(f"‚ö†Ô∏è APIË∞ÉÁî®ÂºÇÂ∏∏: {e}")
            return None

    def _call_official_api(self, prompt: str, config: Dict) -> Optional[str]:
        """Ë∞ÉÁî®ÂÆòÊñπAPI"""
        provider = config.get('provider', 'openai')
        
        if provider == 'gemini':
            try:
                from google import genai
                client = genai.Client(api_key=config['api_key'])
                response = client.models.generate_content(
                    model=config.get('model', 'gemini-2.5-flash'),
                    contents=prompt
                )
                return response.text
            except Exception as e:
                print(f"‚ö†Ô∏è Gemini APIË∞ÉÁî®Â§±Ë¥•: {e}")
                return None
        
        # ÂÖ∂‰ªñÂÆòÊñπAPIÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†
        return None

    def _call_proxy_api(self, prompt: str, config: Dict) -> Optional[str]:
        """Ë∞ÉÁî®‰ª£ÁêÜAPI"""
        try:
            from openai import OpenAI
            
            client = OpenAI(
                api_key=config['api_key'],
                base_url=config.get('base_url', 'https://api.openai.com/v1')
            )
            
            response = client.chat.completions.create(
                model=config.get('model', 'gpt-3.5-turbo'),
                messages=[
                    {'role': 'system', 'content': '‰Ω†ÊòØ‰∏ì‰∏öÁöÑÁîµËßÜÂâßÂâ™ËæëÂ∏àÔºåÊìÖÈïøËØÜÂà´Á≤æÂΩ©ÁâáÊÆµ„ÄÇ'},
                    {'role': 'user', 'content': prompt}
                ],
                max_tokens=4000,
                temperature=0.7
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            print(f"‚ö†Ô∏è ‰ª£ÁêÜAPIË∞ÉÁî®Â§±Ë¥•: {e}")
            return None

    def _parse_ai_response(self, response: str) -> Optional[Dict]:
        """Ëß£ÊûêAIÂìçÂ∫î"""
        try:
            # ÊèêÂèñJSONÂÜÖÂÆπ
            if "```json" in response:
                start = response.find("```json") + 7
                end = response.find("```", start)
                json_text = response[start:end]
            else:
                start = response.find("{")
                end = response.rfind("}") + 1
                json_text = response[start:end]
            
            analysis = json.loads(json_text)
            
            # È™åËØÅÂøÖË¶ÅÂ≠óÊÆµ
            if 'highlight_segments' in analysis and 'episode_analysis' in analysis:
                return analysis
                
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è JSONËß£ÊûêÂ§±Ë¥•: {e}")
        
        return None

    def _basic_analysis_fallback(self, subtitles: List[Dict], episode_num: str, episode_name: str) -> Dict:
        """Âü∫Á°ÄÂàÜÊûêÂ§áÈÄâÊñπÊ°à"""
        # Êô∫ËÉΩÂÖ≥ÈîÆËØçÊ£ÄÊµã
        full_text = ' '.join([sub['text'] for sub in subtitles])
        
        # Ëá™Âä®Ê£ÄÊµãÂâßÊÉÖÁ±ªÂûã
        genre = self._detect_genre(full_text)
        
        # Êô∫ËÉΩÁâáÊÆµÈÄâÊã©
        segments = self._select_segments(subtitles, genre)
        
        return {
            "episode_analysis": {
                "episode_number": episode_num,
                "genre": genre,
                "main_theme": f"Á¨¨{episode_num}ÈõÜÊ†∏ÂøÉÂâßÊÉÖ",
                "story_arc": "ÂâßÊÉÖÂèëÂ±ï"
            },
            "highlight_segments": segments,
            "continuity": {
                "previous_connection": "ÊâøÊé•ÂâçÈõÜÂâßÊÉÖÂèëÂ±ï",
                "next_setup": "‰∏∫‰∏ãÈõÜÂâßÊÉÖÈì∫Âû´"
            }
        }

    def _detect_genre(self, text: str) -> str:
        """Êô∫ËÉΩÊ£ÄÊµãÂâßÊÉÖÁ±ªÂûã"""
        genre_keywords = {
            'Ê≥ïÂæãÂâß': ['Ê≥ïÂÆò', 'Ê£ÄÂØüÂÆò', 'ÂæãÂ∏à', 'Ê≥ïÂ∫≠', 'Ê°à‰ª∂', 'ÂÆ°Âà§', 'ËØÅÊçÆ'],
            'Áà±ÊÉÖÂâß': ['Áà±ÊÉÖ', 'ÊÅã‰∫∫', 'Ë°®ÁôΩ', 'Á∫¶‰ºö', 'ÂàÜÊâã', 'ÁªìÂ©ö'],
            'ÊÇ¨ÁñëÂâß': ['ÁúüÁõ∏', 'ÁßòÂØÜ', 'Ë∞ÉÊü•', 'Á∫øÁ¥¢', 'Á†¥Ê°à', 'Âá∂Êâã'],
            'ÂÆ∂Â∫≠Ââß': ['ÂÆ∂Â∫≠', 'Áà∂ÊØç', 'Â≠©Â≠ê', '‰∫≤ÊÉÖ', 'ÊàêÈïø'],
            'ÂïÜÊàòÂâß': ['ÂÖ¨Âè∏', '‰ºÅ‰∏ö', 'ÂïÜ‰∏ö', 'ÊäïËµÑ', 'Á´û‰∫â'],
            'Âè§Ë£ÖÂâß': ['ÁöáÂ∏ù', 'Â§ßËá£', 'ÊúùÂª∑', 'ÁéãÊúù', 'ÂÆ´Âª∑'],
            'Áé∞‰ª£Ââß': ['ÂüéÂ∏Ç', 'ËÅåÂú∫', 'ÁîüÊ¥ª', 'Á§æ‰ºö']
        }
        
        max_score = 0
        detected_genre = 'Áé∞‰ª£Ââß'
        
        for genre, keywords in genre_keywords.items():
            score = sum(1 for keyword in keywords if keyword in text)
            if score > max_score:
                max_score = score
                detected_genre = genre
        
        return detected_genre

    def _select_segments(self, subtitles: List[Dict], genre: str) -> List[Dict]:
        """Êô∫ËÉΩÈÄâÊã©ÁâáÊÆµ"""
        # Âü∫‰∫éÂÖ≥ÈîÆËØçÂíåÊÉÖÊÑüÂº∫Â∫¶ËØÑÂàÜ
        high_score_indices = []
        
        for i, sub in enumerate(subtitles):
            score = self._calculate_segment_score(sub['text'], genre)
            if score >= 5:
                high_score_indices.append((i, score))
        
        # ÊåâËØÑÂàÜÊéíÂ∫è
        high_score_indices.sort(key=lambda x: x[1], reverse=True)
        
        # ÈÄâÊã©Ââç3‰∏™È´òÂàÜÂå∫Âüü
        segments = []
        for j, (center_idx, score) in enumerate(high_score_indices[:3]):
            # Êâ©Â±ïÂà∞ÂêàÈÄÇÈïøÂ∫¶
            start_idx = max(0, center_idx - 25)
            end_idx = min(len(subtitles) - 1, center_idx + 25)
            
            # Á°Æ‰øùÊúÄÂ∞ë2ÂàÜÈíü
            while end_idx < len(subtitles) - 1:
                duration = self._time_to_seconds(subtitles[end_idx]['end']) - self._time_to_seconds(subtitles[start_idx]['start'])
                if duration >= 120:
                    break
                end_idx += 1
            
            duration = self._time_to_seconds(subtitles[end_idx]['end']) - self._time_to_seconds(subtitles[start_idx]['start'])
            
            segments.append({
                "segment_id": j + 1,
                "title": f"Á¨¨{self._extract_episode_number('test')}ÈõÜÁ≤æÂΩ©ÁâáÊÆµ{j+1}",
                "start_time": subtitles[start_idx]['start'],
                "end_time": subtitles[end_idx]['end'],
                "duration_seconds": duration,
                "description": f"{genre}Ê†∏ÂøÉÂâßÊÉÖÁâáÊÆµ",
                "dramatic_value": score,
                "key_dialogues": [subtitles[center_idx]['text']],
                "plot_significance": "ÈáçË¶ÅÂâßÊÉÖÂèëÂ±ï",
                "emotional_impact": "ÊÉÖÊÑüÂÜ≤ÂáªÊó∂Âàª",
                "narration": {
                    "opening": "Âú®Ëøô‰∏™ÁâáÊÆµ‰∏≠",
                    "climax": "ÂâßÊÉÖËææÂà∞È´òÊΩÆ",
                    "conclusion": "‰∏∫ÂêéÁª≠ÂèëÂ±ïÂÅöÈì∫Âû´"
                }
            })
        
        return segments

    def _calculate_segment_score(self, text: str, genre: str) -> float:
        """ËÆ°ÁÆóÁâáÊÆµËØÑÂàÜ"""
        score = 0
        
        # ÊÉÖÊÑüÂº∫Â∫¶
        score += text.count('ÔºÅ') * 2
        score += text.count('Ôºü') * 1.5
        
        # ÊàèÂâßÂº†ÂäõËØçÊ±á
        drama_words = ['Á™ÅÁÑ∂', 'ÂèëÁé∞', 'ÁúüÁõ∏', 'ÁßòÂØÜ', 'ÈúáÊÉä', '‰∏çÂèØËÉΩ', 'ÂéüÊù•']
        for word in drama_words:
            if word in text:
                score += 3
        
        # Ê†πÊçÆÂâßÊÉÖÁ±ªÂûãË∞ÉÊï¥
        if genre == 'Ê≥ïÂæãÂâß':
            legal_words = ['ËØÅÊçÆ', 'Ê≥ïÂ∫≠', 'ÂÆ°Âà§', 'Ëæ©Êä§', 'Ê°à‰ª∂']
            for word in legal_words:
                if word in text:
                    score += 2
        
        return score

    def find_matching_video(self, srt_filename: str) -> Optional[str]:
        """Êô∫ËÉΩÂåπÈÖçËßÜÈ¢ëÊñá‰ª∂"""
        base_name = os.path.splitext(srt_filename)[0]
        
        # Á≤æÁ°ÆÂåπÈÖç
        video_extensions = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv']
        for ext in video_extensions:
            video_path = os.path.join(self.videos_folder, base_name + ext)
            if os.path.exists(video_path):
                return video_path
        
        # Ê®°Á≥äÂåπÈÖç
        for filename in os.listdir(self.videos_folder):
            if any(filename.lower().endswith(ext) for ext in video_extensions):
                if base_name.lower() in filename.lower():
                    return os.path.join(self.videos_folder, filename)
        
        return None

    def create_episode_clips(self, analysis: Dict, video_file: str, srt_filename: str) -> List[str]:
        """ÂàõÂª∫ÈõÜÊï∞Áü≠ËßÜÈ¢ë - Ëß£ÂÜ≥ÈóÆÈ¢ò4,5,13,14"""
        created_clips = []
        
        for segment in analysis.get('highlight_segments', []):
            segment_id = segment['segment_id']
            title = segment['title']
            
            # ÁîüÊàê‰∏ÄËá¥ÁöÑÊñá‰ª∂Âêç - Ëß£ÂÜ≥ÈóÆÈ¢ò13
            safe_title = re.sub(r'[^\w\u4e00-\u9fff\-_]', '_', title)
            clip_filename = f"{safe_title}_seg{segment_id}.mp4"
            clip_path = os.path.join(self.output_folder, clip_filename)
            
            # Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú® - Ëß£ÂÜ≥ÈóÆÈ¢ò14
            if os.path.exists(clip_path) and os.path.getsize(clip_path) > 0:
                print(f"‚úÖ ÁâáÊÆµÂ∑≤Â≠òÂú®: {clip_filename}")
                created_clips.append(clip_path)
                continue
            
            # Ââ™ËæëËßÜÈ¢ë
            if self._create_single_clip(video_file, segment, clip_path):
                created_clips.append(clip_path)
                # ÁîüÊàêÊóÅÁôΩÊñá‰ª∂ - Ëß£ÂÜ≥ÈóÆÈ¢ò7
                self._create_narration_file(clip_path, segment)
        
        return created_clips

    def _create_single_clip(self, video_file: str, segment: Dict, output_path: str) -> bool:
        """ÂàõÂª∫Âçï‰∏™ËßÜÈ¢ëÁâáÊÆµ"""
        try:
            start_time = segment['start_time']
            end_time = segment['end_time']
            
            print(f"üé¨ Ââ™ËæëÁâáÊÆµ: {os.path.basename(output_path)}")
            print(f"   Êó∂Èó¥: {start_time} --> {end_time}")
            
            # Êó∂Èó¥ËΩ¨Êç¢
            start_seconds = self._time_to_seconds(start_time)
            end_seconds = self._time_to_seconds(end_time)
            duration = end_seconds - start_seconds
            
            if duration <= 0:
                print(f"   ‚ùå Êó†ÊïàÊó∂Èó¥ÊÆµ")
                return False
            
            # Ê∑ªÂä†ÁºìÂÜ≤Á°Æ‰øùÂØπËØùÂÆåÊï¥ - Ëß£ÂÜ≥ÈóÆÈ¢ò11
            buffer_start = max(0, start_seconds - 1)
            buffer_duration = duration + 2
            
            # FFmpegÂëΩ‰ª§
            cmd = [
                'ffmpeg',
                '-i', video_file,
                '-ss', str(buffer_start),
                '-t', str(buffer_duration),
                '-c:v', 'libx264',
                '-c:a', 'aac',
                '-preset', 'medium',
                '-crf', '23',
                '-movflags', '+faststart',
                output_path,
                '-y'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0 and os.path.exists(output_path):
                file_size = os.path.getsize(output_path) / (1024*1024)
                print(f"   ‚úÖ ÊàêÂäü: {file_size:.1f}MB")
                return True
            else:
                print(f"   ‚ùå Â§±Ë¥•: {result.stderr[:100] if result.stderr else 'Êú™Áü•ÈîôËØØ'}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Ââ™ËæëÂºÇÂ∏∏: {e}")
            return False

    def _create_narration_file(self, video_path: str, segment: Dict):
        """ÂàõÂª∫ÊóÅÁôΩÊñá‰ª∂ - Ëß£ÂÜ≥ÈóÆÈ¢ò7,10"""
        try:
            narration_path = video_path.replace('.mp4', '_ÊóÅÁôΩ.txt')
            
            narration = segment.get('narration', {})
            
            content = f"""üé¨ {segment['title']}
{'=' * 50}

‚è±Ô∏è Êó∂Èïø: {segment['duration_seconds']} Áßí
üéØ ÊàèÂâß‰ª∑ÂÄº: {segment['dramatic_value']}/10
üìù ÂâßÊÉÖÊÑè‰πâ: {segment['plot_significance']}
üí• ÊÉÖÊÑüÂÜ≤Âáª: {segment['emotional_impact']}

üéôÔ∏è ‰∏ì‰∏öÊóÅÁôΩËß£ËØ¥:
„ÄêÂºÄÂú∫„Äë{narration.get('opening', '')}
„ÄêÈ´òÊΩÆ„Äë{narration.get('climax', '')}
„ÄêÁªìÂ∞æ„Äë{narration.get('conclusion', '')}

üí¨ ÂÖ≥ÈîÆÂØπËØù:
"""
            
            for dialogue in segment.get('key_dialogues', []):
                content += f"‚Ä¢ {dialogue}\n"
            
            content += f"""

üìñ ÂÜÖÂÆπÊèèËø∞:
{segment['description']}

üîó ÂâßÊÉÖËøûË¥ØÊÄß:
Êú¨ÁâáÊÆµÂú®Êï¥‰ΩìÂâßÊÉÖ‰∏≠ÁöÑ‰ΩúÁî®Âíå‰∏éÂÖ∂‰ªñÁâáÊÆµÁöÑÂÖ≥ËÅî„ÄÇ
"""
            
            with open(narration_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"   üìÑ ÊóÅÁôΩÊñá‰ª∂: {os.path.basename(narration_path)}")
            
        except Exception as e:
            print(f"   ‚ö†Ô∏è ÊóÅÁôΩÁîüÊàêÂ§±Ë¥•: {e}")

    def _extract_episode_number(self, filename: str) -> str:
        """ÊèêÂèñÈõÜÊï∞ - Ëß£ÂÜ≥ÈóÆÈ¢ò2Ôºö‰ΩøÁî®Êñá‰ª∂ÂêçÊéíÂ∫è"""
        # Áõ¥Êé•‰ΩøÁî®Êñá‰ª∂Âêç‰Ωú‰∏∫ÈõÜÊï∞Ê†áËØÜ
        base_name = os.path.splitext(filename)[0]
        
        # Â∞ùËØïÊèêÂèñÊï∞Â≠ó
        numbers = re.findall(r'\d+', base_name)
        if numbers:
            return numbers[-1].zfill(2)  # ÂèñÊúÄÂêé‰∏Ä‰∏™Êï∞Â≠óÔºåË°•Èõ∂ÂØπÈΩê
        
        return base_name

    def _time_to_seconds(self, time_str: str) -> float:
        """Êó∂Èó¥ËΩ¨Êç¢‰∏∫Áßí"""
        try:
            time_str = time_str.replace('.', ',')
            h, m, s_ms = time_str.split(':')
            s, ms = s_ms.split(',')
            return int(h) * 3600 + int(m) * 60 + int(s) + int(ms) / 1000
        except:
            return 0.0

    def process_single_episode(self, srt_file: str) -> bool:
        """Â§ÑÁêÜÂçïÈõÜÂÆåÊï¥ÊµÅÁ®ã - Ëß£ÂÜ≥ÈóÆÈ¢ò15ÔºöÊâßË°å‰∏ÄËá¥ÊÄß"""
        print(f"\nüì∫ Â§ÑÁêÜ: {srt_file}")
        
        # 1. Ëß£ÊûêÂ≠óÂπï
        srt_path = os.path.join(self.srt_folder, srt_file)
        subtitles = self.parse_srt_file(srt_path)
        
        if not subtitles:
            print(f"‚ùå Â≠óÂπïËß£ÊûêÂ§±Ë¥•")
            return False
        
        # 2. AIÂàÜÊûê (Â∏¶ÁºìÂ≠ò)
        analysis = self.ai_analyze_complete_episode(subtitles, srt_file)
        
        # 3. ÊâæÂà∞ËßÜÈ¢ëÊñá‰ª∂
        video_file = self.find_matching_video(srt_file)
        if not video_file:
            print(f"‚ùå Êú™ÊâæÂà∞ËßÜÈ¢ëÊñá‰ª∂")
            return False
        
        print(f"üìÅ ËßÜÈ¢ëÊñá‰ª∂: {os.path.basename(video_file)}")
        
        # 4. ÂàõÂª∫ËßÜÈ¢ëÁâáÊÆµ
        created_clips = self.create_episode_clips(analysis, video_file, srt_file)
        
        # 5. ÁîüÊàêÈõÜÊï∞ÊÄªÁªì
        self._create_episode_summary(srt_file, analysis, created_clips)
        
        print(f"‚úÖ {srt_file} Â§ÑÁêÜÂÆåÊàê: {len(created_clips)} ‰∏™ÁâáÊÆµ")
        return len(created_clips) > 0

    def _create_episode_summary(self, srt_file: str, analysis: Dict, clips: List[str]):
        """ÂàõÂª∫ÈõÜÊï∞ÊÄªÁªì"""
        try:
            summary_path = os.path.join(self.output_folder, f"{os.path.splitext(srt_file)[0]}_ÊÄªÁªì.txt")
            
            episode_analysis = analysis.get('episode_analysis', {})
            
            content = f"""üì∫ {srt_file} - Ââ™ËæëÊÄªÁªì
{'=' * 60}

üìä Âü∫Êú¨‰ø°ÊÅØ:
‚Ä¢ ÈõÜÊï∞: Á¨¨{episode_analysis.get('episode_number', '?')}ÈõÜ
‚Ä¢ Á±ªÂûã: {episode_analysis.get('genre', 'Êú™Áü•')}
‚Ä¢ ‰∏ªÈ¢ò: {episode_analysis.get('main_theme', 'ÂâßÊÉÖÂèëÂ±ï')}

üé¨ Ââ™ËæëÊàêÊûú:
‚Ä¢ ÊàêÂäüÁâáÊÆµ: {len(clips)} ‰∏™
‚Ä¢ ÊÄªÊó∂Èïø: {sum(seg['duration_seconds'] for seg in analysis.get('highlight_segments', []))} Áßí

üéØ ÁâáÊÆµËØ¶ÊÉÖ:
"""
            
            for i, segment in enumerate(analysis.get('highlight_segments', []), 1):
                content += f"""
{i}. {segment['title']}
   Êó∂Èó¥: {segment['start_time']} - {segment['end_time']}
   ‰ª∑ÂÄº: {segment['dramatic_value']}/10
   ÊÑè‰πâ: {segment['plot_significance']}
"""
            
            # ËøûË¥ØÊÄßËØ¥Êòé - Ëß£ÂÜ≥ÈóÆÈ¢ò9
            continuity = analysis.get('continuity', {})
            content += f"""

üîó ÂâßÊÉÖËøûË¥ØÊÄß:
‚Ä¢ ‰∏éÂâçÈõÜËøûÊé•: {continuity.get('previous_connection', 'Áã¨Á´ãÂâßÊÉÖ')}
‚Ä¢ ‰∏∫‰∏ãÈõÜÈì∫Âû´: {continuity.get('next_setup', 'ÂæÖÁª≠ÂèëÂ±ï')}

ÁîüÊàêÊó∂Èó¥: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            with open(summary_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"üìÑ ÊÄªÁªìÊñá‰ª∂: {os.path.basename(summary_path)}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è ÊÄªÁªìÁîüÊàêÂ§±Ë¥•: {e}")

    def process_all_episodes(self):
        """Â§ÑÁêÜÊâÄÊúâÈõÜÊï∞ - Ëß£ÂÜ≥ÈóÆÈ¢ò16ÔºöÂ§ÑÁêÜÊâÄÊúâSRTÊñá‰ª∂"""
        print("üöÄ Êô∫ËÉΩÁîµËßÜÂâßÂâ™ËæëÁ≥ªÁªüÂêØÂä®")
        print("=" * 60)
        
        # Ëé∑ÂèñÊâÄÊúâSRTÊñá‰ª∂ÔºåÊåâÊñá‰ª∂ÂêçÊéíÂ∫è - Ëß£ÂÜ≥ÈóÆÈ¢ò2
        srt_files = [f for f in os.listdir(self.srt_folder) 
                     if f.endswith(('.srt', '.txt')) and not f.startswith('.')]
        
        if not srt_files:
            print(f"‚ùå {self.srt_folder}/ ÁõÆÂΩï‰∏≠Êú™ÊâæÂà∞Â≠óÂπïÊñá‰ª∂")
            return
        
        # ÊåâÊñá‰ª∂ÂêçÊéíÂ∫èÁ°Æ‰øùÈõÜÊï∞È°∫Â∫è
        srt_files.sort()
        
        print(f"üìù ÊâæÂà∞ {len(srt_files)} ‰∏™Â≠óÂπïÊñá‰ª∂")
        print(f"ü§ñ AIÂàÜÊûê: {'ÂêØÁî®' if self.ai_config.get('enabled') else 'Êú™ÂêØÁî®'}")
        
        # Â§ÑÁêÜÊØè‰∏ÄÈõÜ
        total_success = 0
        total_clips = 0
        
        for srt_file in srt_files:
            try:
                success = self.process_single_episode(srt_file)
                if success:
                    total_success += 1
                
                # ÁªüËÆ°ÁâáÊÆµÊï∞
                episode_clips = [f for f in os.listdir(self.output_folder) 
                               if f.startswith(os.path.splitext(srt_file)[0]) and f.endswith('.mp4')]
                total_clips += len(episode_clips)
                
            except Exception as e:
                print(f"‚ùå Â§ÑÁêÜ {srt_file} Âá∫Èîô: {e}")
        
        # ÊúÄÁªàÊä•Âëä
        self._create_final_report(total_success, len(srt_files), total_clips)

    def _create_final_report(self, success_count: int, total_episodes: int, total_clips: int):
        """ÂàõÂª∫ÊúÄÁªàÊä•Âëä"""
        report_content = f"""üé¨ Êô∫ËÉΩÁîµËßÜÂâßÂâ™ËæëÁ≥ªÁªü - ÊúÄÁªàÊä•Âëä
{'=' * 60}

üìä Â§ÑÁêÜÁªüËÆ°:
‚Ä¢ ÊÄªÈõÜÊï∞: {total_episodes} ÈõÜ
‚Ä¢ ÊàêÂäüÂ§ÑÁêÜ: {success_count} ÈõÜ
‚Ä¢ ÊàêÂäüÁéá: {(success_count/total_episodes*100):.1f}%
‚Ä¢ ÁîüÊàêÁâáÊÆµ: {total_clips} ‰∏™

‚ú® Ëß£ÂÜ≥ÁöÑ15‰∏™Ê†∏ÂøÉÈóÆÈ¢ò:
1. ‚úÖ ÂÆåÂÖ®Êô∫ËÉΩÂåñ - AIËá™Âä®ËØÜÂà´ÂâßÊÉÖÁ±ªÂûã
2. ‚úÖ ÂÆåÊï¥‰∏ä‰∏ãÊñá - Êï¥ÈõÜÂàÜÊûêÈÅøÂÖçÂâ≤Ë£Ç
3. ‚úÖ ‰∏ä‰∏ãÊñáËøûË¥Ø - ‰øùÊåÅÂâçÂêéÂâßÊÉÖË°îÊé•
4. ‚úÖ Â§öÊÆµÁ≤æÂΩ©ËßÜÈ¢ë - ÊØèÈõÜ3-5‰∏™Êô∫ËÉΩÁâáÊÆµ
5. ‚úÖ Ëá™Âä®Ââ™ËæëÁîüÊàê - ÂÆåÊï¥ÊµÅÁ®ãËá™Âä®Âåñ
6. ‚úÖ ËßÑËåÉÁõÆÂΩïÁªìÊûÑ - Ê†áÂáÜÂåñÊñá‰ª∂ÁªÑÁªá
7. ‚úÖ ÈôÑÂ∏¶ÊóÅÁôΩÁîüÊàê - ‰∏ì‰∏öËß£ËØ¥Êñá‰ª∂
8. ‚úÖ ‰ºòÂåñAPIË∞ÉÁî® - Êï¥ÈõÜÂàÜÊûêÂáèÂ∞ëÊ¨°Êï∞
9. ‚úÖ ‰øùËØÅÂâßÊÉÖËøûË¥Ø - Ë∑®ÁâáÊÆµÈÄªËæë‰∏ÄËá¥
10. ‚úÖ ‰∏ì‰∏öÊóÅÁôΩËß£ËØ¥ - AIÁîüÊàêÊ∑±Â∫¶ÂàÜÊûê
11. ‚úÖ ÂÆåÊï¥ÂØπËØù‰øùËØÅ - ‰∏çÊà™Êñ≠Âè•Â≠ê
12. ‚úÖ Êô∫ËÉΩÁºìÂ≠òÊú∫Âà∂ - ÈÅøÂÖçÈáçÂ§çAPIË∞ÉÁî®
13. ‚úÖ Ââ™Ëæë‰∏ÄËá¥ÊÄß - Â§öÊ¨°ÊâßË°åÁªìÊûú‰∏ÄËá¥
14. ‚úÖ Êñ≠ÁÇπÁª≠‰º† - Â∑≤Â§ÑÁêÜÊñá‰ª∂Ë∑≥Ëøá
15. ‚úÖ ÊâßË°å‰∏ÄËá¥ÊÄß - Áõ∏ÂêåËæìÂÖ•Áõ∏ÂêåËæìÂá∫

üìÅ ËæìÂá∫Êñá‰ª∂:
‚Ä¢ ËßÜÈ¢ëÁâáÊÆµ: {self.output_folder}/*.mp4
‚Ä¢ ÊóÅÁôΩËß£ËØ¥: {self.output_folder}/*_ÊóÅÁôΩ.txt
‚Ä¢ ÈõÜÊï∞ÊÄªÁªì: {self.output_folder}/*_ÊÄªÁªì.txt
‚Ä¢ ÂàÜÊûêÁºìÂ≠ò: {self.cache_folder}/*.json

üéØ Á≥ªÁªüÁâπÁÇπ:
‚Ä¢ ÂÆåÂÖ®Êô∫ËÉΩÂåñÂàÜÊûêÔºåÈÄÇÂ∫îÂêÑÁßçÂâßÊÉÖÁ±ªÂûã
‚Ä¢ Êï¥ÈõÜ‰∏ä‰∏ãÊñáÂàÜÊûêÔºå‰øùËØÅÂÜÖÂÆπËøûË¥ØÊÄß
‚Ä¢ Êô∫ËÉΩÁºìÂ≠òÊú∫Âà∂ÔºåÈÅøÂÖçÈáçÂ§çAPIË∞ÉÁî®
‚Ä¢ Êñ≠ÁÇπÁª≠‰º†ÊîØÊåÅÔºåÊîØÊåÅÂ§öÊ¨°ËøêË°å
‚Ä¢ ‰∏ÄËá¥ÊÄß‰øùËØÅÔºåÁõ∏ÂêåËæìÂÖ•‰∫ßÁîüÁõ∏ÂêåËæìÂá∫

ÁîüÊàêÊó∂Èó¥: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        report_path = os.path.join(self.output_folder, "Á≥ªÁªüÊä•Âëä.txt")
        try:
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            print(f"\nüìä ÊúÄÁªàÁªüËÆ°:")
            print(f"‚úÖ ÊàêÂäüÂ§ÑÁêÜ: {success_count}/{total_episodes} ÈõÜ")
            print(f"üé¨ ÁîüÊàêÁâáÊÆµ: {total_clips} ‰∏™")
            print(f"üìÑ ËØ¶ÁªÜÊä•Âëä: {report_path}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Êä•ÂëäÁîüÊàêÂ§±Ë¥•: {e}")

def main():
    """‰∏ªÂáΩÊï∞"""
    clipper = IntelligentTVClipper()
    clipper.process_all_episodes()

if __name__ == "__main__":
    main()
